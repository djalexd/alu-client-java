/**
 * Gecad ePayment API
 * ALU, short for Automatic Live Update, is intended for merchants who want to place transactions directly in the PayU system. The main advantage that ALU presents is that it allows the Merchant to also send the Shopper card data. This approach allows merchants full control over their shoppers' experience, meaning that ALU: * Is easy to integrate * Allows custom page design * Is very secure 
 *
 * OpenAPI spec version: 3.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.payu.gecad.alu;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.payu.gecad.ApiException;
import com.payu.gecad.ApiResponse;
import com.payu.gecad.Hashing;

import java.io.IOException;

import java.net.URI;
import java.nio.charset.StandardCharsets;

import com.payu.gecad.alu_model.AluRequest;
import com.payu.gecad.alu_model.AluResponse;
import com.payu.gecad.alu_model.AluResponseRaw;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.message.BasicHeader;
import org.apache.http.message.BasicNameValuePair;

import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class AluApi {
    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    private HttpClient apiClient;

    private URI targetURI;

    private ObjectMapper mapper;

    public AluApi(HttpClient apiClient, URI targetURI, ObjectMapper mapper) {
        this.apiClient = apiClient;
        this.targetURI = targetURI;
        this.mapper = mapper;
    }

    private static <T> Optional<T> resolve(Supplier<T> supp) {
        try {
            return Optional.ofNullable(supp.get());
        } catch (NullPointerException | IndexOutOfBoundsException e) {
            return Optional.empty();
        }
    }

    @SuppressWarnings("all")
    private static ApiException apiException(String parameter) {
        final String msg = "Missing the required parameter '%s'";
        return new ApiException(String.format(msg, parameter));
    }

    static private class SupplierForParameter {
        private final Supplier<String> supp;
        private final String parameter;

        private SupplierForParameter(Supplier<String> supp, String parameter) {
            this.supp = supp;
            this.parameter = parameter;
        }

        static SupplierForParameter from(String parameter, Supplier<String> supp) {
            return new SupplierForParameter(supp, parameter);
        }

        static <T> SupplierForParameter fromAny(String parameter, Supplier<T> supp, Function<T, String> fn) {
            return new SupplierForParameter(() -> fn.apply(supp.get()), parameter);
        }
    }

    static private class OptionalForParameter {
        private final String value;
        private final String parameter;

        private OptionalForParameter(String value, String parameter) {
            this.value = value;
            this.parameter = parameter;
        }

        static <T> Optional<OptionalForParameter> from(SupplierForParameter supplier) {
            return resolve(supplier.supp).map(t -> new OptionalForParameter(t, supplier.parameter));
        }
    }

    private static<A, B, C> Stream<C> zip(Stream<? extends A> a,
                                         Stream<? extends B> b,
                                         BiFunction<? super A, ? super B, ? extends C> zipper) {
        Objects.requireNonNull(zipper);
        Spliterator<? extends A> aSpliterator = Objects.requireNonNull(a).spliterator();
        Spliterator<? extends B> bSpliterator = Objects.requireNonNull(b).spliterator();

        // Zipping looses DISTINCT and SORTED characteristics
        int characteristics = aSpliterator.characteristics() & bSpliterator.characteristics() &
            ~(Spliterator.DISTINCT | Spliterator.SORTED);

        long zipSize = ((characteristics & Spliterator.SIZED) != 0)
            ? Math.min(aSpliterator.getExactSizeIfKnown(), bSpliterator.getExactSizeIfKnown())
            : -1;

        Iterator<A> aIterator = Spliterators.iterator(aSpliterator);
        Iterator<B> bIterator = Spliterators.iterator(bSpliterator);
        Iterator<C> cIterator = new Iterator<C>() {
            @Override
            public boolean hasNext() {
                return aIterator.hasNext() && bIterator.hasNext();
            }

            @Override
            public C next() {
                return zipper.apply(aIterator.next(), bIterator.next());
            }
        };

        Spliterator<C> split = Spliterators.spliterator(cIterator, zipSize, characteristics);
        return (a.isParallel() || b.isParallel())
            ? StreamSupport.stream(split, true)
            : StreamSupport.stream(split, false);
    }

    private static class Indexed<T> {
        T t;
        int index;
        Indexed(T t, int index) {
            this.t = t;
            this.index = index;
        }
    }

    private static <A> Stream<Indexed<A>> zipWithIndex(Stream<? extends A> a) {
        if (a.isParallel()) {
            throw new IllegalArgumentException("Stream must be sequencial");
        }
        return zip(a, Stream.iterate(0, i->i+1), (e, i) -> new Indexed<>(e, i));
    }

    private static BinaryOperator<List<NameValuePair>> merge2Lists() {
        return (list1, list2) -> {
            List<NameValuePair> copy = new ArrayList<>(list1);
            copy.addAll(list2);
            return copy;
        };
    }

    /* Build call for createOrder */
    @SuppressWarnings("all")
    private HttpUriRequest createOrderCall(final AluRequest request) throws ApiException {

        final List<NameValuePair> localVarFormParams = Stream.of(
                SupplierForParameter.from("MERCHANT", ()->request.getMerchant().getKey()),
                SupplierForParameter.from("ORDER_REF", request::getOrderRef),
                SupplierForParameter.fromAny("ORDER_DATE", request::getOrderDate, d->formatter.format(d)),
                SupplierForParameter.fromAny("PAY_METHOD", ()->request.getPayMethod(), e->e.toString()),
                SupplierForParameter.from("BACK_REF", ()->request.getContinueUri()),
                SupplierForParameter.from("CC_NUMBER", ()->request.getPaymentOptions().getCreditCard().getCcNumber()),
                SupplierForParameter.fromAny("EXP_MONTH", ()->request.getPaymentOptions().getCreditCard().getExpMonth(), i->Integer.toString(i)),
                SupplierForParameter.fromAny("EXP_YEAR", ()->request.getPaymentOptions().getCreditCard().getExpYear(), i->Integer.toString(i)),
                SupplierForParameter.from("CC_CVV", ()->request.getPaymentOptions().getCreditCard().getCcNumber()),
                SupplierForParameter.from("CC_OWNER", ()->request.getPaymentOptions().getCreditCard().getCcNumber()),
                SupplierForParameter.from("CC_TOKEN", ()->request.getPaymentOptions().getCreditCard().getCcNumber()),
                SupplierForParameter.fromAny("SELECTED_INSTALLMENTS_NUMBER", ()->request.getPaymentOptions().getInstallments().getNumberOfInstallments(), i->Integer.toString(i)),
                SupplierForParameter.from("CARD_PROGRAM_NAME", ()->request.getPaymentOptions().getInstallments().getCardProgramName()),
                SupplierForParameter.fromAny("ORDER_TIMEOUT", ()->request.getOrderTimeout(), i->Integer.toString(i)),
                SupplierForParameter.fromAny("USE_LOYALTY_POINTS", ()->request.getPaymentOptions().getLoyaltyPoints(), pts->"YES"),
                SupplierForParameter.fromAny("LOYALTY_POINTS_AMOUNT", ()->request.getPaymentOptions().getLoyaltyPoints().getAmount(), d->Double.toString(d)),
                SupplierForParameter.fromAny("CAMPAIGN_TYPE", ()->request.getPaymentOptions().getInstallments().getCampaignType(), e->e.toString()),
                SupplierForParameter.fromAny("ORDER_SHIPPING", ()->request.getShipping().getCost(), c->c.toString()),
                SupplierForParameter.from("POS_CODE", ()->request.getPosCode()),
                SupplierForParameter.from("BILL_LNAME", ()->request.getBilling().getContactPerson().getLastName()),
                SupplierForParameter.from("BILL_FNAME", ()->request.getBilling().getContactPerson().getFirstName()),
                SupplierForParameter.from("BILL_EMAIL", ()->request.getBilling().getContactPerson().getEmail()),
                SupplierForParameter.from("BILL_PHONE", ()->request.getBilling().getContactPerson().getPhone()),
                SupplierForParameter.from("BILL_COUNTRYCODE", ()->request.getBilling().getAddress().getCountryCode()),
                SupplierForParameter.fromAny("BILL_CITYPE", ()->request.getBilling().getDocumentId().getDocumentType(), e->e.toString()),
                SupplierForParameter.from("BILL_CINUMBER", ()->request.getBilling().getDocumentId().getDocumentNumber()),
                SupplierForParameter.from("BILL_FAX", ()->request.getBilling().getFax()),
                SupplierForParameter.from("BILL_ADDRESS", ()->request.getBilling().getAddress().getAddressLine()),
                SupplierForParameter.from("BILL_ADDRESS2", ()->request.getBilling().getAddress().getAddressLine1()),
                SupplierForParameter.from("BIL_ZIPCODE", ()->request.getBilling().getAddress().getZipCode()),
                SupplierForParameter.from("BILL_CITY", ()->request.getBilling().getAddress().getCity()),
                SupplierForParameter.from("BILL_STATE", ()->request.getBilling().getAddress().getState()),
                SupplierForParameter.from("DELIVERY_LNAME", ()->request.getDelivery().getContactPerson().getLastName()),
                SupplierForParameter.from("DELIVERY_FNAME", ()->request.getDelivery().getContactPerson().getFirstName()),
                SupplierForParameter.from("DELIVERY_EMAIL", ()->request.getDelivery().getContactPerson().getEmail()),
                SupplierForParameter.from("DELIVERY_PHONE", ()->request.getDelivery().getContactPerson().getPhone()),
                SupplierForParameter.from("DELIVERY_COMPANY", ()->request.getDelivery().getCompany()),
                SupplierForParameter.from("DELIVERY_ADDRESS", ()->request.getDelivery().getAddress().getAddressLine()),
                SupplierForParameter.from("DELIVERY_ADDRESS2", ()->request.getDelivery().getAddress().getAddressLine1()),
                SupplierForParameter.from("DELIVERY_ZIPCODE", ()->request.getDelivery().getAddress().getZipCode()),
                SupplierForParameter.from("DELIVERY_CITY", ()->request.getDelivery().getAddress().getCity()),
                SupplierForParameter.from("DELIVERY_STATE", ()->request.getDelivery().getAddress().getState()),
                SupplierForParameter.from("DELIVERY_COUNTRYCODE", ()->request.getDelivery().getAddress().getCountryCode()),
                SupplierForParameter.fromAny("LU_ENABLE_TOKEN", ()->request.getPaymentOptions().getCreditCard().getEnableToken(), t->"1"),
                SupplierForParameter.fromAny("LU_TOKEN_TYPE", ()->request.getPaymentOptions().getCreditCard().getEnableToken(), t->"PAY_BY_CLICK"),
                SupplierForParameter.from("CC_NUMBER_TIME", ()->request.getPaymentOptions().getCreditCard().getCcNumberTime()),
                SupplierForParameter.from("CC_OWNER_TIME", ()->request.getPaymentOptions().getCreditCard().getCcOwnerTime()),
                SupplierForParameter.from("CLIENT_IP", ()->request.getClientIp()),
                SupplierForParameter.fromAny("CLIENT_TIME", ()->request.getClientTime(), t->formatter.format(t)),
                SupplierForParameter.from("PRICES_CURRENCY", ()->request.getCurrency()))
            .map(OptionalForParameter::from)
            .filter(o -> o.isPresent())
            .map(o -> o.get())
            .map(p -> (NameValuePair) new BasicNameValuePair(p.parameter, p.value))
            .map(pair -> Arrays.asList(pair))
            .reduce(new ArrayList<NameValuePair>(), merge2Lists());

        final List<NameValuePair> finalList = zipWithIndex(request.getOrderItems().stream())
            .flatMap(i -> {
                return Stream.of(
                    SupplierForParameter.from(String.format("ORDER_PNAME[%d]", i.index), ()->i.t.getName()),
                    SupplierForParameter.from(String.format("ORDER_PCODE[%d]", i.index), ()->i.t.getCode()),
                    SupplierForParameter.fromAny(String.format("ORDER_PRICE[%d]", i.index), ()->i.t.getPrice(), d->d.toString()),
                    SupplierForParameter.fromAny(String.format("ORDER_VAT[%d]", i.index), ()->i.t.getVat(), d->d.toString()),
                    SupplierForParameter.fromAny(String.format("ORDER_PRICE_TYPE[%d]", i.index), ()->i.t.getPriceType(), e->e.toString()),
                    SupplierForParameter.fromAny(String.format("ORDER_QTY[%d]", i.index), ()->i.t.getQuantity(), _i->Integer.toString(_i)),
                    SupplierForParameter.from(String.format("ORDER_PINFO[%d]", i.index), ()->i.t.getInfo()),
                    SupplierForParameter.from(String.format("ORDER_VER[%d]", i.index), ()->i.t.getVersion()));
            })
            .map(OptionalForParameter::from)
            .filter(o -> o.isPresent())
            .map(o -> o.get())
            .map(p -> (NameValuePair) new BasicNameValuePair(p.parameter, p.value))
            .map(pair -> Arrays.asList(pair))
            .reduce(localVarFormParams, merge2Lists());

        final byte[] secretKey = resolve(() -> request.getMerchant().getSecretKey())
            .map(key -> key.getBytes(StandardCharsets.UTF_8))
            .orElseThrow(() -> apiException("MERCHANT_KEY"));

        final Hashing.HashConfiguration cfg = new Hashing.HashConfiguration("HmacMD5", secretKey, true, true, "alphabetically", java.util.Arrays.<String>asList(), java.util.Arrays.<String>asList());
        String hash = new Hashing().calculateHash(localVarFormParams, cfg);
        finalList.add(new BasicNameValuePair("ORDER_HASH", hash));

        HttpPost req = new HttpPost(targetURI);
        req.addHeader(new BasicHeader(HttpHeaders.ACCEPT, "application/xml; text/xml"));
        try {
            req.setEntity(new UrlEncodedFormEntity(localVarFormParams));
            return req;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Create a new order via ALU v3
     *
     * @param aluRequest The ALU request object
     * @return AluResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AluResponse createOrder(final AluRequest aluRequest) throws ApiException {
        return createOrderWithHttpInfo(aluRequest).getData();
    }

    /**
     * Create a new order via ALU v3
     *
     * @param aluRequest The ALU request object
     * @return ApiResponse&lt;AluResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AluResponse> createOrderWithHttpInfo(final AluRequest aluRequest) throws ApiException {
        try {
            final HttpUriRequest request = createOrderCall(aluRequest);
            final HttpResponse resp = apiClient.execute(request);

            if (resp.getStatusLine().getStatusCode() == 200) {
                final AluResponseRaw raw = mapper.readerFor(AluResponseRaw.class).readValue(resp.getEntity().getContent());

                final AluResponse response = new AluResponse()
                    .refNum(raw.getREFNO())
                    .status(resolve(() -> AluResponse.StatusEnum.valueOf(raw.getSTATUS().toString())).orElse(null))
                    .returnCode(resolve(() -> AluResponse.ReturnCodeEnum.byValue(raw.getRETURNCODE())).orElse(null))
                    .amount(raw.getAMOUNT())
                    .currency(raw.getCURRENCY())
                    .installmentsNum(raw.getINSTALLMENTSNO())
                    .cardProgramName(raw.getCARDPROGRAMNAME())
                    .completeTxnRedirectUri(raw.getURLREDIRECT())
                    .cardProgramName(raw.getCARDPROGRAMNAME())
                    .orderRef(raw.getORDERREF())
                    .txnRefNo(raw.getTXREFNO())
                    .tokenHash(raw.getTOKENHASH())
                    .completeTxnRedirectUri(raw.getURLREDIRECT())
                    .continueUri3Ds(raw.getURL3DS());

                return new ApiResponse<>(
                    resp.getStatusLine().getStatusCode(),
                    Collections.emptyMap(),
                    response);
            } else {
                final String msg = "Could not create order, status was %d";
                throw new ApiException(String.format(msg, resp.getStatusLine().getStatusCode()));
            }
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }
}
